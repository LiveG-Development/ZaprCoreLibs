{"dom( ... ).html.set": {"shortDescription": "Set the HTML content of all matching elements.", "longDescription": "", "params": [{"type": "string", "description": "HTML content to set.", "name": "content"}], "return": {}}, "dom( ... ).events.ignore": {"shortDescription": "Ignore the callback given to the future event for all matching elements.", "longDescription": "", "params": [{"type": "string", "description": "Name of event to use.", "name": "event"}, {"type": "function", "description": "Callback to ignore when the event is raised.", "name": "usedCallback"}], "return": {}}, "dom( ... ).html.get": {"shortDescription": "Get the HTML content of the first found matching element.", "longDescription": "", "params": [], "return": {"type": "string", "description": "HTML content of the first found matching element."}}, "dom( ... ).text.set": {"shortDescription": "Set the text content of all matching elements.", "longDescription": "", "params": [{"type": "string", "description": "Text content to set.", "name": "content"}], "return": {}}, "dom( ... ).events.listen": {"shortDescription": "Listen to the given future event for all matching elements, and call function when the event is raised.", "longDescription": "Event bubbling is where the event handling is passed from the first child all the way to the root element. Event capturing is going the other way.", "params": [{"type": "string", "description": "Name of event to listen for.", "name": "event"}, {"type": "function", "description": "Callback to call when the event is raised.", "name": "callback"}, {"type": "boolean", "description": "Use event capturing instead of event bubbling. Default is `false`.", "name": "useCapture"}], "return": {}}, "dom( ... ).text.get": {"shortDescription": "Get the text content of the first found matching element.", "longDescription": "", "params": [], "return": {"type": "string", "description": "Text content of the first found matching element."}}}